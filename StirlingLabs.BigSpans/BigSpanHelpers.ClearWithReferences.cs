using System;
using System.Diagnostics;
using System.Runtime.CompilerServices;

namespace StirlingLabs.Utilities;

internal static partial class BigSpanHelpers
{
    public static unsafe void ClearWithReferences(ref IntPtr ip, nuint pointerSizeLength)
    {
        Debug.Assert((int)Unsafe.AsPointer(ref ip) % sizeof(IntPtr) == 0, "Should've been aligned on natural word boundary.");

        // First write backward 8 natural words at a time.
        // Writing backward allows us to get away with only simple modifications to the
        // mov instruction's base and index registers between loop iterations.

        for (; pointerSizeLength >= 8; pointerSizeLength -= 8)
        {
            Unsafe.Add(ref Unsafe.Add(ref ip, (nint)pointerSizeLength), -1) = default;
            Unsafe.Add(ref Unsafe.Add(ref ip, (nint)pointerSizeLength), -2) = default;
            Unsafe.Add(ref Unsafe.Add(ref ip, (nint)pointerSizeLength), -3) = default;
            Unsafe.Add(ref Unsafe.Add(ref ip, (nint)pointerSizeLength), -4) = default;
            Unsafe.Add(ref Unsafe.Add(ref ip, (nint)pointerSizeLength), -5) = default;
            Unsafe.Add(ref Unsafe.Add(ref ip, (nint)pointerSizeLength), -6) = default;
            Unsafe.Add(ref Unsafe.Add(ref ip, (nint)pointerSizeLength), -7) = default;
            Unsafe.Add(ref Unsafe.Add(ref ip, (nint)pointerSizeLength), -8) = default;
        }

        Debug.Assert(pointerSizeLength <= 7);

        // The logic below works by trying to minimize the number of branches taken for any
        // given range of lengths. For example, the lengths [ 4 .. 7 ] are handled by a single
        // branch, [ 2 .. 3 ] are handled by a single branch, and [ 1 ] is handled by a single
        // branch.
        //
        // We can write both forward and backward as a perf improvement. For example,
        // the lengths [ 4 .. 7 ] can be handled by zeroing out the first four natural
        // words and the last 3 natural words. In the best case (length = 7), there are
        // no overlapping writes. In the worst case (length = 4), there are three
        // overlapping writes near the middle of the buffer. In perf testing, the
        // penalty for performing duplicate writes is less expensive than the penalty
        // for complex branching.

        if (pointerSizeLength >= 4)
        {
            //goto Write4To7; // fall through
        }
        else if (pointerSizeLength >= 2)
            goto Write2To3;
        else if (pointerSizeLength > 0)
            goto Write1;
        else
            return; // nothing to write

        //Write4To7:

        Debug.Assert(pointerSizeLength >= 4);

        // Write first four and last three.
        Unsafe.Add(ref ip, 2) = default;
        Unsafe.Add(ref ip, 3) = default;
        Unsafe.Add(ref Unsafe.Add(ref ip, (nint)pointerSizeLength), -3) = default;
        Unsafe.Add(ref Unsafe.Add(ref ip, (nint)pointerSizeLength), -2) = default;

        Write2To3:
        Debug.Assert(pointerSizeLength >= 2);

        // Write first two and last one.
        Unsafe.Add(ref ip, 1) = default;
        Unsafe.Add(ref Unsafe.Add(ref ip, (nint)pointerSizeLength), -1) = default;

        Write1:
        Debug.Assert(pointerSizeLength >= 1);

        // Write only element.
        ip = default;
    }
}
